#!/bin/bash

# Decides whether a full path is a template or build script, and processes it.
categorize() {
  if [[ $1 =~ .*/([^/]+)-[[:digit:]]+\.template ]]
  then
    extract_templates "$1" "${BASH_REMATCH[1]}" 'style=solid'
  else
    extract_templates "$1" \
      "$(makepkg-expanded -p "$1" \
        -r 'makepkg --printsrcinfo -p "$1"' \
      | grep -Po '(?<=pkgbase = ).*')" \
      'style=bold'
  fi
}

extract_templates() {
  echo "  \"$2\"${3:+ [$3]};"
  grep -Po '(?<=template (input|start); name=).*(?=;|$)' $1 \
    | sed "s/.*/  \"$2\" -> \"\0\";/"
}

echo 'digraph templates {'
echo "  node [style=dashed];"
while [ $OPTIND -le $# ]
do
  if getopts 'h' argument
  then
    case $argument in
      h) {
        seen=true
        echo "usage: $0 [options | files ...]"
        echo 'display template inclusion relation in graphiz dot format'
        echo ' -h  only shows this help text'
      } >&2 ;;
      \?) exit 1 ;;
    esac
  else
    categorize "${!OPTIND}"
    seen=true
    let OPTIND++
  fi
done
if [ -z ${seen++} ]
then
  while read -rd $'' file
  do
    categorize $file
  done < <( find -regextype posix-egrep \
    \( -name 'PKGBUILD' -o -regex '.*-[[:digit:]]+\.template' \) \
    -print0 )
fi
echo '}'
