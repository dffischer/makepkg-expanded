#!/bin/bash

# initialize gettext
export TEXTDOMAIN='pacman-scripts'

# parse arguments
invalid_option() {
  echo "$0: $(gettext "invalid option") -- '-'" >&2
}

while [ $OPTIND -le $# ]
do
  if getopts ':hp:a-:' argument
  then
    case $argument in
      h)
        echo "usage: $0 [options]"
        echo 'builds the PKGBUILD found in the current directory, expanding makepkg-templates' \
          'but leaving the original intact apart from the version numbers.'
        echo 'Templates are taken from a makepkg-templates directory found besides this script.'
        echo 'Valid options are:'
        echo ' -h              show this help text'
        echo ' -p <script>     select an alternative file instead of PKGBUILD'
        echo ' -a              select all PKGBUILDs to be found below the current directory'
        echo 'All other arguments are passed to makepkg.'
        exit ;;
      p) packages+=("$OPTARG") ;;
      a)
        while read -r -d $'\0'; do
          packages+=("$REPLY")
        done < <(find ! -readable -prune -o -iname PKGBUILD -print0)
        ;;
      \?) pass+=("-$OPTARG") ;;
      -) lastarg=$((OPTIND - 1))
        case "${!lastarg}" in
          # Long arguments may be tried to be handled here. Avoid shift
          # though, it most probably breaks the surrounding routine.
          --*) pass+=("--$OPTARG") ;;
          *) invalid_option
            exit 1 ;;
        esac ;;
      :) [ $OPTARG = - ] && invalid_option ||
        echo "$0: $(gettext "option requires an argument") -- '-$OPTARG'" >&2
        exit 1 ;;
    esac
  else
    pass+=("${!OPTIND}")
    let OPTIND++
  fi
done

templates=(
  --template-dir
  "$(grep -Po "(?<=^\ttemplate_dir => \[').*(?='\],$)" $(which makepkg-template))"
  --template-dir
  "$(realpath ${BASH_SOURCE[@]%/*})/makepkg-templates"
)

# process PKGBUILDs
for path in ${packages[@]:-PKGBUILD}
do
  if [ ! -f "$path" ]
  then
    printf "$0: $(gettext "%s file (%s) does not exist or is not a regular file.")\n" "build script" "$path"
  else
    # Plain suffix removal does not suffice as $path may be just a filename.
    dir="$(dirname "$path")"
    file="${path##*/}"
    ( cd "$dir"

      # expand and clean
      makepkg-template -p "$file" -o PKGBUILD.expanded "${templates[@]}" || exit $?
      sed -i '/# \(template\|vim\)/d' PKGBUILD.expanded

      # build
      makepkg -p PKGBUILD.expanded "${pass[@]}" || exit $?
      makepkg -Sp PKGBUILD.expanded "${pass[@]}" || exit $?

      # propagate changed pkgver
      oldpkgver=$(grep -Po '(?<=^pkgver=)[^ ]*' "$file")
      newpkgver=$(grep -Po '(?<=^pkgver=)[^ ]*' PKGBUILD.expanded)
      if [ $newpkgver != $oldpkgver ]
      then
        if [ -w "$file" ]
        then
          sed --follow-symlinks -i "s:^pkgver=[^ ]*:pkgver=$newpkgver:;s:^pkgrel=[^ ]*:pkgrel=1:" "$file"
        else
          printf "$0: $(gettext "%s is not writeable -- pkgver will not be updated")\n" "$file"
        fi
      fi
    ) || exit $?
  fi
done
