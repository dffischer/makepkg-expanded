#!/bin/bash

# initialize gettext
export TEXTDOMAIN='pacman-scripts'

# parse arguments
invalid_option() {
  echo "$0: $(gettext "invalid option") -- '-'" >&2
  exit 1
}

add_all() {
  while read -r -d $'\0'; do
    packages+=("$REPLY")
  done < <(find ! -readable -prune -o -iname ${1:-PKGBUILD} -print0)
}

function='
  mksource () {
    makepkg -S "$@"
  }
'

while [ $OPTIND -le $# ]
do
  if getopts ':hp:a:t:b:BulE:-:' argument
  then
    case $argument in
      h)
        echo "usage: $0 [options]"
        echo 'builds the PKGBUILD found in the current directory, expanding makepkg-templates' \
          'but leaving the original intact apart from the version numbers.'
        echo 'Valid options are:'
        echo ' -h              show this help text'
        echo ' -p <script>     select an alternative file instead of PKGBUILD'
        echo ' -a [pattern]    select all files matching the given pattern, or all PKGBUILDs'
        echo ' -t <dir>        directory to look up templates in'
        echo ' -b <extension>  extension for intermediate expanded build scripts'
        echo ' -B              do not generate source aurball, just build package'
        echo ' -u              keep template markers intact'
        echo ' -l              keep duplicate templates'
        echo ' -E <command>    command to execute for each PKGBUILD'
        echo 'All other arguments are passed to makepkg.'
        exit ;;
      p) packages+=("$OPTARG") ;;
      a) add_all "$OPTARG" ;;
      t) templates+=(--template-dir "$(realpath "$OPTARG")") ;;
      b) extension="$OPTARG" ;;
      B) function='
        mksource() {
          :
        }' ;;
      u)
        if declare -f | grep -q sed
        then
          clean-template() {
            cat
          }
        else
          clean-template() {
            command clean-template -u
          }
        fi ;;
      l)
        if declare -f | grep -q command
        then
          clean-template() {
            cat
          }
        else
          clean-template() {
            sed '/# vim/d;x;$G;/# template/d;1d'
          }
        fi ;;
      E) process="$OPTARG" ;;
      \?) pass+=("-$OPTARG") ;;
      -) lastarg=$((OPTIND - 1))
        case "${!lastarg}" in
          # Long arguments may be tried to be handled here. Avoid shift
          # though, it most probably breaks the surrounding routine.
          --*) pass+=("--$OPTARG") ;;
          *) invalid_option ;;
        esac ;;
      :)
        case "$OPTARG" in
          a) add_all ;;
          -) invalid_option ;;
          *) echo "$0: $(gettext "option requires an argument") -- '-$OPTARG'" >&2
            exit 1 ;;
        esac
    esac
  else
    pass+=("${!OPTIND}")
    let OPTIND++
  fi
done

if [ "${#templates[@]}" -le 0 ]
then
  templates=("$(grep -Po "(?<=^\ttemplate_dir => \[').*(?='\],$)" $(which makepkg-template))")
  gitdir="$(git rev-parse --show-toplevel)/makepkg-templates"
  if [ $? -eq 0 -a -d "$gitdir" ]
  then
    templates+=("$gitdir")
  fi
fi


# process PKGBUILDs
for path in "${packages[@]:-PKGBUILD}"
do
  if [ ! -f "$path" ]
  then
    printf "$0: $(gettext "%s file (%s) does not exist or is not a regular file.")\n" "build script" "$path"
  else
    # Plain suffix removal does not suffice as $path may be just a filename.
    dir="$(dirname "$path")"
    file="${path##*/}"
    expanded="$file${extension:=.expanded}"
    ( cd "$dir" #(

      # expand and clean
      makepkg-template -p "$file" -o - "${templates[@]/#/--template-dir=}" | \
        clean-template > "$expanded"
      [ ${PIPESTATUS[0]} -ne 0 ] && exit ${PIPESTATUS[0]}

      # process
      bash -c "${process:-"$function
        makepkg -p \"\$1\" \"\$@\" || exit \$?
        mksource -p \"\$1\" \"\$@\" || exit \$?
        exec cp-pkgver \"\$1\" \"\$2\"
      "}" process-expanded "$expanded" "$file" "${pass[@]}" || exit $?
    ) || exit $? #)
  fi
done
